#!groovy 
pipeline {
    environment {
        GIT_SSH_COMMAND = 'ssh -i key'
        AZURE_CONFIG_DIR = "${env.WORKSPACE}/tmp/azure"
        KUBECONFIG_DIR = "${env.WORKSPACE}/tmp"
        KUBECONFIG = "${env.KUBECONFIG_DIR}/kube.yaml"
        GIT_REPO = "git@ssh.dev.azure.com:v3/Dataspace4Health/DS4H/helm-identity-and-trust"
        DNS_NAME = 'dataspace4health.local'
        HOST_PATH = '/home/jenkins/host'
    }
    parameters {
        string(name: "registery", description: "Azure Container Registery Name", defaultValue: "dh4sdev")
        string(name: "registery_domain", description: "Azure Container Registery domaine name", defaultValue: "dh4sdev.azurecr.io")
    }
    agent {label 'worker'}
    stages {
        stage("Clone Remote Repository") {
            steps {
                git credentialsId: 'azure-devops', branch: 'jenkins', url: env.GIT_REPO
                withCredentials([sshUserPrivateKey(credentialsId: 'azure-devops', keyFileVariable: 'SSH_KEY')]) {
                    sh('cp "$SSH_KEY" key')
                    sh('chmod 400 key')
                }
                sh "mkdir -p $KUBECONFIG_DIR"
                sh "mkdir -p $AZURE_CONFIG_DIR"
            }
        }

        stage("Create K3d Cluster and Test") {
            steps {
                script {
                    // Package charts 
                    sh 'make build'
                    def testsDirExists = sh(script: "if [ -d tests ]; then echo 'exists'; else echo 'not exists'; fi", returnStdout: true).trim()
                    // Create cluster
                    def cluster = createCluster()
                    // Perform root tests
                    mainTest(cluster)
                    def version = get_version()
                    def latest_tag = get_latest_tag()
                    if (latest_tag == version) {
                        env.exit = "true"
                        echo "Version not changed. Pipeline exit."
                    }
                }
            }
        }

        stage ("Ask User Validation") {
            when {
                expression {
                    return env.exit != "true"
                }
            }
            steps {
                script {
                    def response = input(
                        id: 'test', 
                        message: "Do you want to push the chart with The test results",
                        parameters: [
                            [$class: 'ChoiceParameterDefinition', 
                                choices: "No\nYes", 
                                description: "Checkout the test report of the federated catalog, you find the report on the side bar",
                                name: workspace]
                        ]
                    )
                    if (response == "No") {
                        env.exit = "true"
                        echo "User not satisfied with the tests. Pipeline exit."
                    }
                }
            }
        }

        stage ("Azure Login"){
            when {
                expression {
                    return env.exit != "true"
                }
            }
            steps {
                withCredentials([
                    string(credentialsId: 'app_id', variable: 'APP_ID'),
                    string(credentialsId: 'sub_id', variable: 'SUB_ID'), 
                    string(credentialsId: 'tenant_id', variable: 'TENANT_ID'), 
                    string(credentialsId: 'sp_password', variable: 'SP_PASSWORD'),
                ]) {
                    sh('az login --service-principal --username $APP_ID --password $SP_PASSWORD --tenant $TENANT_ID')
                    sh('az account set --subscription $SUB_ID')
                    sh("az acr login --name ${params.registery}")
                }
            }
        }

        stage ("Tag Remote Repository and publish helm chart") {
            when {
                expression {
                    return env.exit != "true"
                }
            }
            steps {
                script {
                    def version = get_version()
                    def latestCommit = sh(script: "git rev-parse HEAD", returnStdout: true).trim()
                    // publish helm chart
                    sh "helm push helm/*.tgz oci://${registery_domain}/helm"
                    // tag git repo
                    sh "git tag ${version} ${latestCommit}"
                    sh "git push origin ${version}"
                    sh('az logout')
                }
            }
        }
    }
    post {
        always {
            script {
                if (fileExists('cluster_name.txt')) {
                    def clusterName = readFile('cluster_name.txt').trim()
                    sh "k3d cluster delete ${clusterName}"
                }
                cleanWs()
            }
        }
    }
}

def get_version(){
    def version = sh(script: "yq '.version' Chart.yaml -r", returnStdout: true).trim()
    return version
}

def get_name() {
    def name = sh(script: "yq '.name' Chart.yaml -r", returnStdout: true).trim()
    return name
}

def get_latest_tag() {
    sh "git fetch --tags"
    def latest_tag = sh(script: "git for-each-ref --sort=-creatordate --format '%(refname:strip=2)' refs/tags | head -n 1", returnStdout: true).trim()
    if(latest_tag) {
        return latest_tag
    } else {
       return null
    }
}

def getCredential(id) {
    def credential = 'None'
    try {
        withCredentials([string(credentialsId: id, variable: 'TEMP_CREDENTIAL')]) {
            if (TEMP_CREDENTIAL) {
                credential = TEMP_CREDENTIAL
                echo "Credential ${id} is set."
            } else {
                echo "Credential ${id} is not set, falling back to empty string."
            }
        }
    } catch (Exception e) {
        echo "Credential ${id} not found or an error occurred, falling back to empty string."
    }
    return credential
}

def createCluster(){
    def cluster = [:]
    def random = UUID.randomUUID().toString().take(10)
    cluster.name = "jenkins-${random}"
    sh "k3d cluster create ${cluster.name} --servers 1 --agents 3 --no-lb --kubeconfig-update-default=false --kubeconfig-switch-context=false"
    writeFile file: 'cluster_name.txt', text: cluster.name
    sh "k3d kubeconfig get ${cluster.name} > ${env.KUBECONFIG}"
    sh "chmod 600 ${env.KUBECONFIG}"
    cluster.net = sh(script: "docker inspect -f '{{range \$key, \$value := .NetworkSettings.Networks}}{{println \$key}}{{end}}' k3d-${cluster.name}-server-0", returnStdout: true).trim()
    cluster.server_ip = sh(script: "docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' k3d-${cluster.name}-server-0", returnStdout: true).trim()
    sh """
    until kubectl -n kube-system get configmap coredns > /dev/null 2>&1; do
        echo "Waiting for ConfigMap 'coredns' to be available..."
        sleep 5
    done
    """
    withCredentials([
        string(credentialsId: 'app_id', variable: 'APP_ID'),
        string(credentialsId: 'sp_password', variable: 'SP_PASSWORD'),
    ]) {
        env.REG = params.registery_domain
        sh('kubectl create secret docker-registry acr-creds --docker-server=$REG --docker-username=$APP_ID --docker-password=$SP_PASSWORD')
    }
    sh "kubectl apply -f jenkins-files/traefik-config.yaml"
    sh "helm repo add jetstack https://charts.jetstack.io --force-update"
    sh "helm repo update"
    sh "helm install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace --version v1.14.4 --set installCRDs=true"
    sh "kubectl apply -f jenkins-files/ca-issuer.yaml"
    sh "kubectl apply -f jenkins-files/ca-certificate.yaml"
    sh "kubectl apply -f jenkins-files/issuer.yaml"
    sh "kubectl apply -f jenkins-files/certificate.yaml"
    sh "kubectl wait --for=condition=Ready certificate/${env.DNS_NAME} --timeout=300s"
    sh """
    kubectl -n kube-system get cm coredns -o yaml | sed 's#NodeHosts: |#NodeHosts: |\\n    ${cluster.server_ip} ${env.DNS_NAME}#' | kubectl apply -f -
    """
    def version = get_version()
    def name = get_name()
    // sh "helm install identity-and-trust ./helm/${name}-${version}.tgz -f jenkins-files/values.yaml"
    sh """
    make install override_values="-f jenkins-files/values.yaml"
    """
    return cluster
}

def mainTest(cluster) {
    sh "kubectl wait --for=condition=Ready pods --all --timeout=3600s"
    def testsDirExists = sh(script: "if [ -d tests ]; then echo 'exists'; else echo 'not exists'; fi", returnStdout: true).trim()
    if (testsDirExists != 'exists') {
        sh("echo No tests directory found in the main")
        return
    }
    def time = sh(script: 'date "+%Y.%m.%d-%H.%M.%S"', returnStdout: true).trim()
    def name = "jenkins-playwrite-${cluster.name}"
    sh """
    make test name="${name}" timestamp="${time}" network="${cluster.net}" dns_cmd="docker exec ${name} bash -c 'echo ${cluster.server_ip} ${env.DNS_NAME} >> /etc/hosts'"
    """
    sh "ls tests/results/${time}/traces"
    sh "ls tests/results/${time}/report"
    publishHTML([allowMissing: false, alwaysLinkToLastBuild: true, keepAll: true, reportDir: "tests/results/${time}/report", reportFiles: 'index.html', reportName: 'Test Report']) 
}
