#!groovy 
pipeline {
    environment {
        GIT_SSH_COMMAND = 'ssh -i key'
        KUBECONFIG_DIR = "${env.WORKSPACE}/tmp"
        KUBECONFIG = "${env.KUBECONFIG_DIR}/kube.yaml"
        DNS_NAME = 'dataspace4health.local'
        HELM_REPO = 'git@ssh.dev.azure.com:v3/Dataspace4Health/DS4H/helm-identity-and-trust'
        VC_ISSUER_REPO = 'git@ssh.dev.azure.com:v3/Dataspace4Health/DS4H/keycloak-vc-issuer'
        WALTID_IDPKIT_REPO = 'git@ssh.dev.azure.com:v3/Dataspace4Health/DS4H/waltid-idpkit'
        WALT_IDENTITY_REPO = 'git@ssh.dev.azure.com:v3/Dataspace4Health/DS4H/waltid-identity'
        // BRANCH_NAME = 'jenkins'
        FALLBACK_BRANCH = 'main'
        REGISTRY = 'localhost:5000'
        REGISTRY_NAME = 'k3d-registry.localhost:5000'
    }

    agent {label 'worker'}

    stages {
        stage("Setup git and kubectl access") {
            steps {
                script {
                    initSetup()
                }
            }
        }

        stage("Build VC Issuer Image") {
            steps {
                script {
                    buildVCIssuerImage()
                }
            }
        }

        stage("Build Wallet Identity UI and API Images") {
            steps {
                script {
                    buildWaltidImages()
                }
            }
        }

        stage("Create K3d Cluster and Test") {
            steps {
                script {
                    // Create cluster
                    def cluster = createCluster()
                    // deploy helm idenity and trust
                    deployIT(cluster)
                }
            }
        }

        stage("Clean Up") {
            steps {
                script {
                    cleanup()
                }
            }
        }
    }

    post {
        always {
            script {
                postCleanup()
            }
        }
    }
}

def cloneRepo(repo, name) {
    // Check if the branch exists remotely
    def branchExists = sh(
        script: "git ls-remote --heads ${repo} ${env.BRANCH_NAME}",
        returnStatus: true
    ) == 0
    def branchToUse = branchExists ? env.BRANCH_NAME : env.FALLBACK_BRANCH
    echo "Using branch: ${branchToUse} for ${name}"
    // clone and checkout using the branch
    sh "git clone --branch ${branchToUse} ${repo} ${name}"
}

def buildVCIssuerImage() {
    cloneRepo(env.VC_ISSUER_REPO, 'vc-issuer')
    // switch to the vc issuer repo and build the image
    dir('vc-issuer') {
        // Build UI
        def random = UUID.randomUUID().toString()
        def randomImageName = "jenkins-generated-image-vcissuer:${random}"
        env.vc_issuer_image_name = "jenkins-generated-image-vcissuer"
        env.vc_issuer_image_tag = random
        sh "docker build -t ${randomImageName} -f deploy/Dockerfile-init ."
        sh "docker tag ${randomImageName} ${env.REGISTRY}/${randomImageName}"
        sh "docker push ${env.REGISTRY}/${randomImageName}"
    }
}

def buildWaltidImages() {
    cloneRepo(env.WALT_IDENTITY_REPO, 'walletid')
    // switch to the wallet identity repo and build the image
    dir('walletid') {
        // Build UI
        def random = UUID.randomUUID().toString()
        def randomImageName = "jenkins-generated-image-walletidui:${random}"
        env.walletid_ui_image_name = "jenkins-generated-image-walletidui"
        env.walletid_ui_image_tag = random
        sh "docker build -t ${randomImageName} -f waltid-applications/waltid-web-wallet/apps/waltid-dev-wallet/Dockerfile ."
        sh "docker tag ${randomImageName} ${env.REGISTRY}/${randomImageName}"
        sh "docker push ${env.REGISTRY}/${randomImageName}"
        // Build API
        random = UUID.randomUUID().toString()
        randomImageName = "jenkins-generated-image-walletidapi:${random}"
        env.walletid_api_image_name = "jenkins-generated-image-walletidapi"
        env.walletid_api_image_tag = random
        sh "docker build -t ${randomImageName} -f waltid-services/waltid-wallet-api/Dockerfile ."
        sh "docker tag ${randomImageName} ${env.REGISTRY}/${randomImageName}"
        sh "docker push ${env.REGISTRY}/${randomImageName}"
    }
}

def override_values(values, file) {
    for (def key in values.keySet()) {
        if (values[key] == '[]') {
            sh """
            yq eval -i '${key}=${values[key]}' ${file}
            """
        } else {
            sh """
            yq eval -i '${key}="${values[key]}"' ${file}
            """
        }
    }
}

def createCluster(){
    def cluster = [:]
    def random = UUID.randomUUID().toString().take(10)
    cluster.name = "jenkins-${random}"
    sh "k3d cluster create ${cluster.name} --servers 1 --no-lb --registry-use ${env.REGISTRY_NAME} --kubeconfig-update-default=false --kubeconfig-switch-context=false"
    writeFile file: 'cluster_name.txt', text: cluster.name
    sh "k3d kubeconfig get ${cluster.name} > ${env.KUBECONFIG}"
    sh "chmod 600 ${env.KUBECONFIG}"
    cluster.net = sh(script: "docker inspect -f '{{range \$key, \$value := .NetworkSettings.Networks}}{{println \$key}}{{end}}' k3d-${cluster.name}-server-0", returnStdout: true).trim()
    cluster.server_ip = sh(script: "docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' k3d-${cluster.name}-server-0", returnStdout: true).trim()
    sh """
    until kubectl -n kube-system get configmap coredns > /dev/null 2>&1; do
        echo "Waiting for ConfigMap 'coredns' to be available..."
        sleep 5
    done
    """
    sh "kubectl apply -f jenkins-files/traefik-config.yaml"
    sh "helm repo add jetstack https://charts.jetstack.io --force-update"
    sh "helm repo update"
    sh "helm install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace --version v1.14.4 --set installCRDs=true"
    sh "kubectl apply -f jenkins-files/ca-issuer.yaml"
    sh "kubectl apply -f jenkins-files/ca-certificate.yaml"
    sh "kubectl apply -f jenkins-files/issuer.yaml"
    sh "kubectl apply -f jenkins-files/certificate.yaml"
    sh "kubectl wait --for=condition=Ready certificate/${env.DNS_NAME} --timeout=300s"
    sh """
    kubectl -n kube-system get cm coredns -o yaml | \
    sed 's#NodeHosts: |#NodeHosts: |\\n    ${cluster.server_ip} ${env.DNS_NAME}#' | \
    kubectl apply -f -
    """
    return cluster
}

def waitAllPods() {
    int retries = 10
    int interval = 60
    for (int i = 0; i < retries; i++) {
        echo "Attempt ${i + 1} of ${retries}..."
        try {
            sh "kubectl wait --for=condition=Ready pods --all --timeout=${interval}s"
            echo "All pods are ready!"
            break
        } catch (err) {
            echo "Attempt ${i + 1}, pods not ready"
        }
    }
}

def mainTest(cluster, report_name) {
    waitAllPods()
    def testsDirExists = sh(script: "if [ -d tests ]; then echo 'exists'; else echo 'not exists'; fi", returnStdout: true).trim()
    if (testsDirExists != 'exists') {
        sh("echo No tests directory found in the main")
        return
    }
    def time = sh(script: 'date "+%Y.%m.%d-%H.%M.%S"', returnStdout: true).trim()
    def name = "jenkins-playwrite-${cluster.name}"
    sh """
    make test name="${name}" timestamp="${time}" network="${cluster.net}" dns_cmd="docker exec ${name} bash -c 'echo ${cluster.server_ip} ${env.DNS_NAME} >> /etc/hosts'"
    """
    sh "ls tests/results/${time}/traces"
    sh "ls tests/results/${time}/report"
    publishHTML([allowMissing: false, alwaysLinkToLastBuild: true, keepAll: true, reportDir: "tests/results/${time}/report", reportFiles: 'index.html', reportName: report_name]) 
}

def deployIT(cluster) {
    // clone helm repo
    cloneRepo(env.HELM_REPO, 'helm-identity-and-trust')
    dir('helm-identity-and-trust') {
        // override the values 
        def values = [
            '.wallet-ui.image.repository' : "${env.REGISTRY_NAME}", 
            '.wallet-ui.image.name' : "${env.walletid_ui_image_name}",
            '.wallet-ui.image.tag' : "${env.walletid_ui_image_tag}",
            '.wallet-ui.image.pullSecrets' : "", 
            '.wallet-api.image.repository' : "${env.REGISTRY_NAME}", 
            '.wallet-api.image.name' : "${env.walletid_api_image_name}", 
            '.wallet-api.image.tag' : "${env.walletid_api_image_tag}", 
            '.wallet-api.image.pullSecrets' : "", 
        ]
        override_values(values, 'jenkins-files/values.yaml')
        values = [
            '(.iam.keycloak.initContainers[] | select(.name == "iam-keycloak-vc-issuer-init")).image': "${env.REGISTRY_NAME}/${env.vc_issuer_image_name}:${env.vc_issuer_image_tag}", 
            '.iam.keycloak.image.pullSecrets': '[]', 
        ]
        override_values(values, 'values.yaml')
        sh('cat jenkins-files/values.yaml')
        sh('head -n 50 values.yaml')
        // Package charts 
        sh 'make build'
        // deploy package 
        sh 'make install override_values="-f jenkins-files/values.yaml"'
        // Perform tests
        mainTest(cluster, 'Helm Identity and trust Test Report')
    }
}

def cleanup() {
    sh "docker rmi ${REGISTRY}/${env.vc_issuer_image_name}:${env.vc_issuer_image_tag}"
    sh "docker rmi ${env.vc_issuer_image_name}:${env.vc_issuer_image_tag}"
    sh "docker rmi ${REGISTRY}/${env.walletid_ui_image_name}:${env.walletid_ui_image_tag}"
    sh "docker rmi ${env.walletid_ui_image_name}:${env.walletid_ui_image_tag}"
}

def postCleanup(){
    if (fileExists('helm-identity-and-trust/cluster_name.txt')) {
        def clusterName = readFile('helm-identity-and-trust/cluster_name.txt').trim()
        sh "k3d cluster delete ${clusterName}"
    }
    cleanWs()
}

def initSetup() {
    // setup git permissions
    withCredentials([sshUserPrivateKey(credentialsId: 'azure-devops', keyFileVariable: 'SSH_KEY')]) {
        sh('cp "$SSH_KEY" key')
        sh('chmod 400 key')
    }
    // create kubeconfig dir
    sh "mkdir -p $KUBECONFIG_DIR"
}